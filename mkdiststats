#!/usr/bin/perl

use POSIX;

use GD;
use Time::Local 'timelocal_nocheck';

use Getopt::Long;
Getopt::Long::Configure("no_ignore_case");

my $width = 1000;
my $height = 450;

my $opt_justgraph;
my $opt_interesting;
my $opt_allinteresting;
my $verbose;
my $maxiter = 0;

my $numlongest = 10;

GetOptions (
    'justgraph' => \$opt_justgraph,
    'numlongest=s' => \$numlongest,
    'interesting=s' => \$opt_interesting,
    'allinteresting' => \$opt_allinteresting,
    'verbose' => \$verbose,
    'maxiter' => \$maxiter,
) or exit(1);

sub unify {
    my %h = map {$_ => 1} @_;
    return grep(delete($h{$_}), @_);
}

sub hhmm {
  my $t = shift;
  $t /= 60;
  return sprintf("%02d:%02d", int($t / 60), $t % 60);
}

my $dist = shift @ARGV;
die("No dist specified!\n") unless $dist ne '';

$templdir = ".";
$ddir = $dist;
$ddir =~ s,/,::,g;
mkdir "output", 0755;
$ddir = "output/$ddir";

my $lastfinfn = "$ddir/lastfin";

mkdir $ddir, 0755 unless -d $ddir;
die unless -d $ddir;

goto drawgraph if $opt_justgraph;

open(LASTFIN, '>', $lastfinfn);

my $pack = undef;
my $text = undef;

sub handle_builddep($)
  {
      my $self = shift;
      my $tag = shift;
      my %attrs = {};
      while (my $attr = shift) {
        $attrs{$attr} = shift;
      }
      if ($tag eq 'package') {
	$pack = $attrs{"name"};
	my @array;
        $deps{$pack} = [ @array ];	
        $subpacks{$pack} = [ @array ];
        push @packs_to_setup, $pack;
      }
      return;
}

sub handle_end_builddep($)
{
  my ($e, $name) = @_;
  if ($name eq 'pkgdep') {
    push(@{$deps{$pack}}, $text);
    return;
  }
  if ($name eq 'subpkg') {
    push(@{$subpacks{$pack}}, $text);
    $subpack2pack{$text} = $pack;
    return;
  }
}

sub handle_ch_builddep($) {
   my $sef = shift;
   $text = shift;
}

require XML::Parser;
my $pdep = new XML::Parser( Handlers => {Start => \&handle_builddep, End => \&handle_end_builddep, Char => \&handle_ch_builddep});

my $fn = "$ddir/_builddepinfo.xml";
if (! -e $fn) {
	print "retreiving builddepinfo\n";
	system("osc api '/build/$dist/_builddepinfo' > $fn");
}
print "parsing build deps ...\n";
$pdep->parsefile($fn, ProtocolEncoding => 'UTF-8');

$now = time;
$now_m = POSIX::strftime("%Y-%m-%d", localtime($now - 30 * 24 * 3600));
$now_a = POSIX::strftime("%Y-%m-%d", localtime($now - 90 * 24 * 3600));

#goto nixda;

%failed;

use Data::Dumper;
sub handle_start($)
  {  
      my $self = shift;
      my $tag = shift;
      return unless ($tag eq 'jobhist');
      my %attrs = {};
      while (my $attr = shift) {
        $attrs{$attr} = shift;
      }
      #print Dumper(\%attrs) . "\n";
      my $package = $attrs{"package"};
      my $client = $attrs{"workerid"};
      my $readytime = $attrs{"readytime"};
      my $starttime = $attrs{"starttime"};
      my $endtime = $attrs{"endtime"};

  my $t = $endtime - $starttime;
  my $ti = $starttime - $readytime;
  my $tb = $endtime - $readytime;

  if ($attrs{"code"} eq "failed") {
      print "FAILED: $package $t $ti $tb\n";
      if (!exists $failed{$package} || $failed{$package} < $t) {
	  $failed{$package} = $t;
      }
      return;
  }
  if (!$packmin_m{$package} || $packmin_m{$package}->[0] > $t) {
    $packmin_m{$package} = [$t, $ti, $tb];
  }
  return unless !$packmin{$package} || $packmin{$package} > $t || $starttime le $now_a;
  $packmin{$package} = $t;
  }

$fn = "$ddir/_jobhistory.xml";
if (! -e $fn) {
	print "retreiving jobhistory\n";
	system("osc api '/build/$dist/_jobhistory?code=lastfailures' > $fn");
}
my $p1 = new XML::Parser( Handlers => {Start => \&handle_start});
print "parsing jobhistory...\n";
$p1->parsefile($fn, ProtocolEncoding => 'UTF-8');

for $pack (@packs_to_setup) {
  if (!$packmin{$pack}) {
    if ($failed{$pack}) {
	$packmin{$pack} = $failed{$pack};
	if ($packmin{$pack} < 300) {
	    print STDERR "$pack failed quickly, assuming five minutes\n";
	    $packmin{$pack} = 300;
	} else {
	    print STDERR "$pack failed, guessing time\n";
	}
    } else {
	print STDERR "unknown build time for $pack\n";
	$packmin{$pack} = 300;
    }
  }
}

#######################################################################
#######################################################################
###
###  Sort specfiles
###

print "calculating dependencies...\n";
# map dependencies to real packages, ignore - deps, filter out self
for $pack (@packs_to_setup) {
  $pdeps{$pack} = [ unify(grep {$_ ne $pack} map {$subpack2pack{$_} || ()} grep {!/^-/} @{$deps{$pack} || []}) ];
}

@todo = @packs_to_setup;

%unknowndep = ();
@unknowndep = ();
%nearly_alls = ();

%known = map {$_ => 1} @todo;
%done = ();
@done = ();
%needed = ();
for $p (@todo) {
  next unless $pdeps{$p};
  for (@{$pdeps{$p}}) {
    if ($known{$_}) {
      $needed{$_}++;
    } else {
      $nearly_alls{$p} = 1 if $_ eq 'nearly-all';
      $unknowndep{$_} = [] unless $unknowndep{$_};
      push @{$unknowndep{$_}}, $p;
      $done{$_} = 1;
      push @unknowndep, $_;
    }
  }
}

@basepacks = map {$subpack2pack{$_} || $_} @basesubpacks;
%basepacks = map {$_ => 1} @basepacks;

# pre-sort ?
@todo = sort {$needed{$b} <=> $needed{$a} || $a cmp $b} @todo;

$numpacks = @todo;

# unify all basepacks
if (@basepacks) {
  $cycle = join(',', sort @basepacks);
  for $p (@todo) {
    next unless $pdeps{$p};
    for (@{$pdeps{$p}}) {
      $_ = $cycle if $basepacks{$_};
    }
  }
  @mdeps = ();
  for $p (@basepacks) {
    next unless $pdeps{$p};
    push @mdeps, grep {$_ ne $cycle} @{$pdeps{$p}};
  }
  @mdeps = ();
  @mdeps = unify(@mdeps);
  $pdeps{$cycle} = [ @mdeps ] if @mdeps;
  $mneeded = 0;
  for (@basepacks) {
    $mneeded = $needed{$_} if $needed{$_} > $mneeded;
  }
  $needed{$cycle} = $mneeded;

  # put basepacks in front
  @todo = grep {!$basepacks{$_}} @todo;
  unshift @todo, $cycle;
} else {
  my $n = @todo;
  @todo = grep {$_ ne 'autoconf'} @todo;
  unshift @todo, 'autoconf' if $n != @todo;
}

print "sorting ...\n";
$now = time;

# sort everything
while (@todo) {
  $firsttodo = $todo[0];
  %need = ($firsttodo => 1) unless %need;
  $one = 0;
  for $p (splice @todo) {
    if (!$need{$p}) {
      push @todo, $p;
      next;
    }
    if ($pdeps{$p} && grep {!$done{$_}} @{$pdeps{$p}}) {
      for (@{$pdeps{$p}}) {
	$one = 1 if $need{$_}++ == 0;
      }
      push @todo, $p;
      next;
    }
    #print "$p\n";
    push @done, $p;
    $done{$p} = 1;
    $one = 1;
    %need = () if $p eq $firsttodo;
  }
  if (!$one) {
    @circtest = sort {$needed{$b} <=> $needed{$a}} grep {$need{$_}} @todo;
    @cyclefound = ();
  circloop:
    while ($p = shift @circtest) {
      @circ = ($p); 
      %circ = ($p => [$p]);
      while (@circ) {
        for $c (splice @circ) {
          for (@{$pdeps{$c} || []}) {
            next if $done{$_};
            if ($_ eq $p) {
	      @cyclefound= @{$circ{$c}};
              last circloop;
            }
            next if exists $circ{$_};
            push @circ, $_;
            $circ{$_} = [@{$circ{$c}}, $_];
          }
        }
        @circ = unify(@circ);
      }
    }
    die unless @cyclefound > 1;
    #print "CYCLE:\n";
    #for $p (@cyclefound) {
    #  print "$p: @{$pdeps{$p}}\n";
    #}

    # unify cycle
    @cycle = map {split(',', $_)} sort @cyclefound;
    $cycle = join(',', @cycle);
    %cyclefound = map {$_ => 1} @cyclefound;
    for $p (@todo) {
      next unless $pdeps{$p};
      for (@{$pdeps{$p}}) {
        $_ = $cycle if $cyclefound{$_};
      }
    }
    @mdeps = ();
    for $p (@cyclefound) {
      die if $p eq 'nearly-all';
      next unless $pdeps{$p};
      push @mdeps, grep {$_ ne $cycle} @{$pdeps{$p}};
    }
    @mdeps = unify(@mdeps);
    $pdeps{$cycle} = [ @mdeps ] if @mdeps;
    $mneeded = 0;
    for (@cyclefound) {
      $mneeded = $needed{$_} if $needed{$_} > $mneeded;
    }
    $needed{$cycle} = $mneeded;
    @todo = map {$cyclefound{$_} ? $cycle : $_} @todo;
    @todo = unify(@todo);
    %need = ();
  }
}

$now = time-$now;
print "done sorting in $now secs\n";

# put nearly alls to back
@nas = grep {$nearly_alls{$_}} @done;
@done = grep {!$nearly_alls{$_}} @done;
push @done, @nas;

# put autoconf cycle to front
if (!@basepacks) {
  @ac = grep {",$_," =~ /,autoconf,/ } @done;
  if (@ac) {
    die if @ac > 1;
    if ($done[0] ne $ac[0]) {
      @done = grep {$_ ne $ac[0]} @done;
      unshift @done, $ac[0];
      $pdeps{$ac[0]} = [];
    }
  }
}

print "Basepacks timings:\n";
for $pack (split(',', $done[0])) {
  print "$pack: $packmin{$pack}\n";
}

@todo = @done;
%done = ();
$done{$_} = 2 for @unknowndep;

$ti = 0;
$nbuild = 0;
# die unless $todo[0] =~ /,/;
$firstcycle = ($todo[0] =~ /,/) ? $todo[0] : '';
print "first cycle: $firstcycle\n";

my %cycles;
for $p (keys %pdeps) {
  @deps = unify(@{$pdeps{$p}});
  # prepare arrays for cycles so we don't need to split them in
  # inner loop later
  for $dep (@deps) {
    @c = split(/,/, $dep);
    if (@c > 1) {
      $cycles{$dep} = [@c];
    }
  }
  $pdeps{$p} = [@deps];
}

open(FOO, '>', "$ddir/deps");
print FOO Data::Dumper->Dump(
    [$firstcycle, \%pdeps, \%packmin, \%cycles],
    [qw/firstcycle  *pdeps   *packmin   *cycles /]);
close FOO;

print "calculating reverse graph ...\n";
use Dfs;
my $dfs = new Dfs(\%pdeps);
for my $cycle (keys %cycles) {
    $dfs->{'nodes'}->{$cycle} = [];
}
$dfs->startrdfs(@todo);
#print Dumper($dfs->{'reversedgraph'});

%deppath = ();

%nbuild = ();
%nwait = ();
$maxnbuild = 0;

$now = time;
$cnt = 0;

$nwait = @todo;
for my $p (splice @todo) {
    if($dfs->{'reverseorder'}->{$p}==0) {
	push @todo, $p;
    }
}
print "number of packages $nwait\n";

my %building;
my %finished;
while ($nwait || $nbuild)
{
  ++$cnt;
  last if $maxiter && $cnt > $maxiter;
  my $numstarted = 0;

  if ($ti) {
    die "BUG: nothing finishes at $ti!\n" unless exists $building{$ti};
    my $nfinish = @{$building{$ti}};
    $nbuild -= $nfinish;
    for my $p (@{$building{$ti}}) {
      print "$ti: finished $p\n" if $verbose;
      $finished{$p} = $ti;
      for my $dep (@{$dfs->{'reversedgraph'}->{$p}}) {
	$dfs->{'reverseorder'}->{$dep}--;
	push @todo, $dep if $dfs->{'reverseorder'}->{$dep} == 0;
      }
      delete $dfs->{'reverseorder'}->{$node};
    }
    delete $building{$ti};
  }

  $nbuild += @todo;
  $numstarted += @todo;
  $nwait -= @todo;
  die "nwait < 0\n" if $nwait < 0;
  my $i = 0;
  for my $p (splice @todo) {
    my $eti = 0;
    if ($cycles{$p}) {
      for (@{$cycles{$p}}) {
	$eti = $packmin{$_} if $eti < $packmin{$_};
      }
      $eti *= 2;
    } else {
      $eti = $packmin{$p};
    }
    $eti += $ti;
    print "$ti: starting $p, will finish at $eti\n" if $verbose;
    $building{$eti} = [] unless exists $building{$eti};
    push @{$building{$eti}}, $p;
  }

  $nbuild{$ti} = $nbuild;
  $maxnbuild = $nbuild if $maxnbuild < $nbuild;
  $nwait{$ti}  = $nwait;
  print "$ti: build $nbuild wait $nwait started $numstarted\n" if $verbose;

  if ($nbuild == 0 && $nwait > 0) {
    die "deadlocked\n";
  }

  my $nextti = 0;
  for $t (keys %building) {
    if (!$nextti) {
      $nextti = $t;
      next;
    }
    $nextti = $t if $t < $nextti;
  }
  last unless $nextti;
  $ti = $nextti;

#  if ($numtodo)
#    {
#      for ($i=0; $i < @todo; ++$i) {
#	$p = $todo[$i];
#	next unless $p;
#        @deps = @{$pdeps{$p} || []};
#	if ($cycles{$p}) {
#	  @pp = @{$cycles{$p}};
#	} else {
#	  @pp = ($p);
#	}
#	if (grep {$done{$_} != 2} @deps) {
#	  #push @todo, $p;
#	  $nwait += @pp;
#	  next;
#	}
#	if (@pp == 1 && $firstcycle && $done{$firstcycle} != 2) {
#	  #push @todo, $p;
#	  $nwait += @pp;
#	  next;
#	}
#	$todo[$i] = undef;
#	++$numstarted;
#	print "$ti: starting $p\n" if $verbose;
#        $nbuild += @pp;
#        $n = 0;
#	for (@pp) {
#	  $n = $packmin{$_} if $n < $packmin{$_};
#	}
#	$n *= 2 if @pp > 1;
#	$eti = $ti + $n;
#	$lpath = '';
#	for $l (@deps) {
#	  $lpath = $deppath{$l} if $deppath{$l} == $ti;
#        }
#	$lpath =~ s/.*? //;
#	$lpath = "$eti $lpath $p($n)";
#	push @sched, [$eti, $p, $lpath];
#      }
#    }
#  $numtodo -= $numstarted;
#  die "argl" if $numtodo < 0;
#  if ($nbuild == 0 && $nwait > 0) {
#    for $p (@todo) {
#        @deps = @{$pdeps{$p} || []};
#	if ($cycles{$p}) {
#	  @pp = @{$cycles{$p}};
#	} else {
#	  @pp = ($p);
#	}
#	print "$p waiting for:";
#	for $pp (grep {$done{$_} != 2} @deps) {
#	  print " $pp";
#        }
# 	print "\n";
#    }
#    die;
#  }
#  $nbuild{$ti} = $nbuild;
#  $maxnbuild = $nbuild if $maxnbuild < $nbuild;
#  $nwait{$ti}  = $nwait;
#  my $numsched = @sched;
#  print "$ti: build $nbuild wait $nwait started $numstarted sched $numsched\n";
#  if ($numsched) {
#    @sched = sort {$a->[0] <=> $b->[0]} @sched;
#    $s = shift @sched;
#    ($ti, $p, $lpath) = @{$s};
#    if ($cycles{$p}) {
#      @pp = @{$cycles{$p}};
#    } else {
#      @pp = ($p);
#    }
#    $deppath{$p} = $lpath;
#    $lpath =~ s/.*? //;
#    $lpath =~ s/\Q$firstcycle\E/basepacks/ if $firstcycle;
#    print "$ti: finished $p: $lpath\n" if $verbose;
#    print LASTFIN "$p $lpath\n";
#    $done{$p} = 2;
#    $nbuild -= @pp;
#  }
}
$nbuild{$ti} = 0;
$nwait{$ti}  = 0;
close LASTFIN;

#print Dumper(\%nbuild, $ti);
$now = time-$now;
print "simulation done after $now secs\n";

open(FOO, '>', "$ddir/simul");
print FOO Data::Dumper->Dump(
    [$numpacks, \%nbuild, \%nwait, \%needed, \%packmin_m],
    [qw/numpacks *nbuild   *nwait   *needed   *packmin_m/]);
close FOO;

my $last;
for my $p (keys %finished) {
  if (!$last) {
    $last = $p;
    next;
  }
  $last = $p if $finished{$last} < $finished{$p};
}

print "last: $last\n";
my @longest;
while(1) {
  push @longest, $last;
  last unless @{$pdeps{$last}};
  my $l;
  for my $dep (@{$pdeps{$last}}) {
    if (!$l) {
      $l = $dep;
      next;
    }
    $l = $dep if $finished{$l} < $finished{$dep};
  }
  $last = $l;
}

#print Dumper(\@longest);

drawgraph:
if ($opt_justgraph) {
    open(FOO, '<', "$ddir/simul") || die "$!";
    eval join('', <FOO>);
    close FOO;
    $maxnbuild = 0;
    $ti = 0;
    for (keys %nbuild) {
	$maxnbuild = $nbuild{$_} if ($maxnbuild < $nbuild{$_});
	$ti = $_ if ($ti < $_);
    }
}

%inttimes = ();
print "Last finished:\n";
$lastfincols = @longest;
for $p (@longest) {
  # skip package with short build time that doesn't trigger many
  # other packages
  next if !$opt_allinteresting && $packmin{$p} < 500 && $needed{$p} < 20;
  $inttimes{$finished{$p}} = $p;
}
print "Interesting:\n";
for $t (sort {$a <=> $b} keys %inttimes) {
  print "$t: $inttimes{$t}\n";
}

$nn = $maxnbuild * 1.2;
$nn = $numpacks if $numpacks < $nn;

my $yaxisround;
$yaxisround = $nn > 200 ? 100 : 10;

$xaxisend = int(($ti + 3600 - 1) / 3600) * 3600;
$yaxisend = int(($nn + $yaxisround - 1) / $yaxisround) * $yaxisround;
$xaxisstep = int($xaxisend / 12);
$xaxisstep = int(($xaxisstep + 3600 - 1) / 3600) * 3600;
$yaxisstep = int($yaxisend / 10);
$yaxisstep = int(($yaxisstep + $yaxisround / 2 - 1) / $yaxisround) * $yaxisround;
$yaxisstep = $yaxisround == $yaxisend ? $yaxisround / 5 : $yaxisround unless $yaxisstep;
$xaxisstep = int($xaxisstep / 4);
$yaxisstep = int($yaxisstep / 5);
$yaxisstep = 1 unless $yaxisstep;

my $image = new GD::Image($width, $height);
$black = $image->colorAllocate (0, 0, 0);
$white = $image->colorAllocate (0xff, 0xff, 0xff);
$blue = $image->colorAllocate (0, 0, 255);
$lblue = $image->colorAllocate (110, 200, 255);
my $gray    = $image->colorAllocate (128, 128, 128);
#my $grayd   = $image->colorAllocate (64, 64, 64);
$grayd = $black;
my $back    = $image->colorAllocate (0xee, 0xee, 0xee);
my $red     = $image->colorAllocate (255,   0,   0);
$image->filledRectangle (0, 0, $width - 1, $height - 1, $back);
$ixoff = 60;
$iyoff = 30;
my $SmallFontWidth = gdSmallFont->width;
my $SmallFontHeight = gdSmallFont->height;
$iw = $width - $ixoff - 20;
$ih = $height - $iyoff - $SmallFontHeight * 6;


$image->filledRectangle ($ixoff, $iyoff, $ixoff + $iw - 1, $iyoff +$ih - 1, $white);

$ox = 0;
for $t (sort {$a <=> $b} keys %nbuild) {
  $x = $ixoff + int($iw / $xaxisend * $t);
  $y1 = $iyoff + $ih - 1 - int($ih / $yaxisend * ($nbuild{$t} + $nwait{$t}));
  $y2 = $iyoff + $ih - 1 - int($ih / $yaxisend * ($nbuild{$t}));
  $y1 = $iyoff if $y1 < $iyoff;
  $y2 = $iyoff if $y2 < $iyoff;
  if ($ox) {
    $image->filledRectangle($ox, $oy1, $x, $oy2, $blue);
    $image->filledRectangle($ox, $oy2, $x, $iyoff + $ih - 1, $lblue);
  }
  $ox = $x;
  $oy1 = $y1;
  $oy2 = $y2;
}

$image->rectangle($ixoff, $iyoff, $ixoff + $iw - 1, $iyoff +$ih - 1, $gray);
$xax = $xaxisstep;
$sub = 1;
while ($xax < $xaxisend) {
  $x = $ixoff + int($iw / $xaxisend * $xax);
  if ($sub) {
    $image->setStyle ($gray, gdTransparent, gdTransparent);
  } else {
    $image->setStyle ($grayd, gdTransparent, gdTransparent);
  }

  $image->line($x, $iyoff, $x, $iyoff + $ih - 1, gdStyled);
  $image->line($x, $iyoff + $ih - 3, $x, $iyoff +$ih, $sub ? $gray : $grayd);
  $image->line($x, $iyoff - 1, $x, $iyoff + 2, $sub ? $gray : $grayd);
  if ($sub == 0) {
    $str = hhmm($xax);
    $strw = $SmallFontWidth * length($str);
    $image->string(gdSmallFont, $x - $strw/2, $iyoff +$ih + 5, $str, $black);
  }
  $xax += $xaxisstep;
  $sub = ($sub + 1) % 4;
}

$yax = $yaxisstep;
$sub = 1;
while ($yax < $yaxisend) {
  $y = $iyoff + $ih - 1 - int($ih / $yaxisend * $yax);
  if ($sub) {
    $image->setStyle ($gray, gdTransparent, gdTransparent);
  } else {
    $image->setStyle ($grayd, gdTransparent, gdTransparent);
  }
  $image->line($ixoff, $y, $ixoff + $iw - 1, $y, gdStyled);
  $image->line($ixoff - 1, $y, $ixoff + 2, $y, $sub ? $gray : $grayd);
  $image->line($ixoff + $iw - 3, $y, $ixoff + $iw, $y, $sub ? $gray : $grayd);

  if ($sub == 0) {
    $str = "$yax";
    $strw = $SmallFontWidth * length($str);
    $image->string(gdSmallFont, $ixoff - $strw - 5, $y - $SmallFontHeight/2, $str, $black);
  }
  $yax += $yaxisstep;
  $sub = ($sub + 1) % 5;
}

my $TinyFontWidth = gdTinyFont->width;
my $TinyFontHeight = gdTinyFont->height;
$yy = 0;
for $t (sort {$a <=> $b} keys %inttimes) {
  $x = $ixoff + int($iw / $xaxisend * $t);
  $y = $iyoff + $ih + 20 + $SmallFontHeight + $yy * $TinyFontHeight;
  $image->line($x, $iyoff + $ih - 1, $x, $y, $gray);
  $str = $inttimes{$t};
  $str = substr($str, 0, 10);
  $strw = $TinyFontWidth * length($str);
  $image->filledRectangle($x - $strw - 1, $y - $TinyFontHeight, $x - 1, $y, $back);
  $image->string(gdTinyFont, $x - $strw - 1, $y - $TinyFontHeight, $str, $black);
  $yy++;
  $yy = 0 if $yy == 5;
}

$str = "# of packages";
$strw = $SmallFontWidth * length($str);
$image->stringUp(gdSmallFont, 7, $iyoff + $ih/2 + $strw/2, $str, $black);

$str = "Rebuildtime $dist";
$strw = gdMediumBoldFont->width() * length($str);
$image->string(gdMediumBoldFont, $width/2 - $strw/2, 5, $str, $black);

open(IMG, ">$ddir/rebuild.png") || die("$ddir/rebuild.png: $!\n");
print IMG $image->png;
close IMG;

open(IN, "<$templdir/disttemplate.html") || die("$templdir/disttemplate.html: $!\n");
$in = '';
while (sysread(IN, $in, 4096, length($in)) > 0) {}
close IN;

$in =~ s/\<DIST\>/$dist/sg;
$h=hhmm($ti);
$in =~ s/\<REBUILDTIME\>/$h/sg;
$in =~ s/\<NUMPACKS\>/$numpacks/sg;

print "making longes table\n";
$colspan = $lastfincols * 3 + 1;
$ltab = "<table cellpadding=0 cellspacing=0 border=0>\n<tr>\n<td colspan=$colspan width=1 bgcolor=\"#336699\"><img src=void.gif width=1 height=1 border=0></td>\n</tr>\n";
for $lf (reverse @interesting) {
  $ltab .= "<tr>\n";
  @lf = split(' ', $lf);
  shift @lf;
  unshift @lf, '' while @lf < $lastfincols;
  for $q (reverse @lf) {
    $ltab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=18 border=0></td>\n";
    if ($q =~ /^(.*)\((.*)\)$/) {
      $ltab .= "<td>&nbsp;$1:</td>\n";
      $h=hhmm($2);
      $ltab .= "<td align=right>&nbsp;$h&nbsp;</td>\n";
    } else {
      $ltab .= "<td>&nbsp;</td><td>&nbsp;</td>\n";
    }
  }
  $ltab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=1 border=0></td>\n";
  $ltab .= "</tr>\n";
}
$ltab .= "<tr>\n<td colspan=$colspan width=1 bgcolor=\"#336699\"><img src=void.gif width=1 height=1 border=0></td>\n</tr>\n</table>\n";
$in =~ s/\<TABLE_LONGEST\>/$ltab/s;

print "making packmin table\n";
@packmin_m = sort {$packmin_m{$b}->[0] <=> $packmin_m{$a}->[0]} keys %packmin_m;
$rtab = "<table cellpadding=0 cellspacing=0 border=0>\n<tr>\n<td colspan=7 width=1 bgcolor=\"#336699\"><img src=void.gif width=1 height=1 border=0></td>\n</tr>\n";
$rtab .= "<tr>\n";
$rtab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=18 border=0></td>\n";
$rtab .= "<td align=center bgcolor=\"#336699\">&nbsp;&nbsp;&nbsp;<font color=\"#ffffff\"><i>Package</i></font>&nbsp;&nbsp;&nbsp;</td>\n";
$rtab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=1 border=0></td>\n";
$rtab .= "<td align=center bgcolor=\"#336699\">&nbsp;&nbsp;&nbsp;<font color=\"#ffffff\"><i>init_buildsystem</i></font>&nbsp;&nbsp;&nbsp;</td>\n";
$rtab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=1 border=0></td>\n";
$rtab .= "<td align=center bgcolor=\"#336699\">&nbsp;&nbsp;&nbsp;<font color=\"#ffffff\"><i>build</i></font>&nbsp;&nbsp;&nbsp;</td>\n";
$rtab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=1 border=0></td>\n";
$rtab .= "</tr>\n";
$rtab .= "<tr>\n<td colspan=7 width=1 bgcolor=\"#336699\"><img src=void.gif width=1 height=1 border=0></td>\n</tr>\n";
for $pack (splice(@packmin_m, 0, 50)) {
  $rtab .= "<tr>\n";
  $rtab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=18 border=0></td>\n";
  $rtab .= "<td bgcolor=\"#eeeeee\">&nbsp;$pack&nbsp;</td>\n";
  $rtab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=1 border=0></td>\n";
  $h = hhmm($packmin_m{$pack}->[1]);
  $rtab .= "<td align=right>&nbsp;&nbsp;&nbsp;$h&nbsp;&nbsp;&nbsp;</td>\n";
  $rtab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=1 border=0></td>\n";
  $h = hhmm($packmin_m{$pack}->[2]);
  $rtab .= "<td align=right>&nbsp;&nbsp;&nbsp;$h&nbsp;&nbsp;&nbsp;</td>\n";
  $rtab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=1 border=0></td>\n";
  $rtab .= "</tr>\n";
}
$rtab .= "<tr>\n<td colspan=7 width=1 bgcolor=\"#336699\"><img src=void.gif width=1 height=1 border=0></td>\n</tr>\n</table>\n";
$in =~ s/\<TABLE_LONGPACKS\>/$rtab/s;

open(IN, ">$ddir/index.html") || die("$ddir/index.html: $!\n");
print IN $in;
close IN;
