#!/usr/bin/perl -w

use POSIX;
use strict;

use Time::Local 'timelocal_nocheck';

use Data::Dumper;

use Getopt::Long;
Getopt::Long::Configure("no_ignore_case");

require XML::Parser;

# graph dimensions
my $width = 1000;
my $height = 450;

# assume this build time if none available
my $default_build_time = 3333;

my $opt_justgraph;
my $opt_interesting;
my $opt_allinteresting;
my $debug;
my $verbose;
my $maxiter = 0;
my $ddir;
my $srcdir;
my $opt_timing;

my $numlongest = 10;

GetOptions (
    'justgraph' => \$opt_justgraph,
    'numlongest=s' => \$numlongest,
    'interesting=s' => \$opt_interesting,
    'allinteresting' => \$opt_allinteresting,
    'verbose' => \$verbose,
    'maxiter' => \$maxiter,
    'debug' => \$debug,
    'destdir=s' => \$ddir,
    'srcdir=s' => \$srcdir,
    'timing' => \$opt_timing,
) or exit(1);

my %subpacks;
my @packs_to_setup;
my %deps;
my %subpack2pack;
my %failed;
my %buildtime;
my %pdeps;
my @todo;
my @basesubpacks;
my @done;
my $maxtime = 0;

sub unify {
    my %h = map {$_ => 1} @_;
    return grep(delete($h{$_}), @_);
}

sub hhmm {
  my $t = shift;
  $t /= 60;
  return sprintf("%02d:%02d", int($t / 60), $t % 60);
}

my $starttime;
sub taskstart {
  return unless $opt_timing;
  print $_[0], " ...\n";
  $starttime = time;
}

sub taskdone {
  return unless $opt_timing;
  my $t = time-$starttime;
  print "done in $t secs\n";
}

my $dist = shift @ARGV;
die("No dist specified!\n") unless $dist ne '';

my $templdir = ".";
if (!$ddir) {
  $ddir = $dist;
  $ddir =~ s,/,_,g;
  mkdir "output", 0755;
  $ddir = "output/$ddir";
  mkdir $ddir, 0755 unless -d $ddir;
}

die "$ddir must be a directory\n" unless -d $ddir;

goto drawgraph if $opt_justgraph;

my $pack = undef;
my $text = '';

sub handle_builddep($)
{
  my $self = shift;
  my $name = shift;
  my %attrs = @_;
  if ($name eq 'package' && exists $attrs{"name"}) {
    $pack = $attrs{"name"};
    my @array;
    $deps{$pack} = [ @array ];	
    $subpacks{$pack} = [ @array ];
    push @packs_to_setup, $pack;
  } elsif ($name eq 'pkgdep' || $name eq 'subpkg') {
    $text = '';
  }
  return;
}

sub handle_end_builddep($)
{
  my ($e, $name) = @_;
  if ($name eq 'pkgdep') {
    push(@{$deps{$pack}}, $text);
  } elsif ($name eq 'subpkg') {
    push(@{$subpacks{$pack}}, $text);
    $subpack2pack{$text} = $pack;
  }
  $text = '';
}

sub handle_ch_builddep($) {
   my $sef = shift;
   $text .= shift;
}

my $pdep = new XML::Parser(
  Handlers => {
    Start => \&handle_builddep,
    End => \&handle_end_builddep,
    Char => \&handle_ch_builddep
  });

my $file = ($srcdir?$srcdir:$ddir)."/_builddepinfo.xml";
if (! -e $file) {
  die "_builddepinfo.xml not found" if $srcdir;
  print "retreiving builddepinfo\n";
  system("osc api '/build/$dist/_builddepinfo' > $file");
}
taskstart "parsing build deps";
$pdep->parsefile($file, ProtocolEncoding => 'UTF-8');
taskdone;


#goto nixda;

sub handle_start($)
{  
  my $self = shift;
  my $tag = shift;
  return unless ($tag eq 'jobhist');
  my %attrs = @_;
  #print Dumper(\%attrs) . "\n";
  my $package = $attrs{"package"};
  my $client = $attrs{"workerid"};
  my $readytime = $attrs{"readytime"};
  my $starttime = $attrs{"starttime"};
  my $endtime = $attrs{"endtime"};

  return unless $package;
  return unless exists $deps{$package};

  my $t = $endtime - $starttime;
  my $ti = $starttime - $readytime;
  my $tb = $endtime - $readytime;

  if ($attrs{"code"} eq "failed") {
    #print "FAILED: $package $t $ti $tb\n";
    if (!exists $failed{$package} || $failed{$package} < $t) {
      $failed{$package} = $t;
    }
    return;
  }
  return unless !$buildtime{$package} || $buildtime{$package} > $t;
  $buildtime{$package} = $t;
}

$file = ($srcdir?$srcdir:$ddir)."/_jobhistory.xml";
if (! -e $file) {
  die "_jobhistory.xml not found" if $srcdir;
  print "retreiving jobhistory\n";
  system("osc api '/build/$dist/_jobhistory?code=lastfailures' > $file");
}
my $p1 = new XML::Parser(
  Handlers => {
    Start => \&handle_start
  });
taskstart "parsing jobhistory";
$p1->parsefile($file, ProtocolEncoding => 'UTF-8');
taskdone;

for $pack (@packs_to_setup) {
  if (!$buildtime{$pack}) {
    if ($failed{$pack}) {
	$buildtime{$pack} = $failed{$pack};
	if ($buildtime{$pack} < $default_build_time) {
	    print "$pack failed quickly, using default time\n";
	    $buildtime{$pack} = $default_build_time;
	} else {
	    print "$pack failed, using default time\n";
	}
    } else {
	print "$pack never built, using default time\n";
	$buildtime{$pack} = $default_build_time;
    }
  }
}


taskstart "calculating dependencies";
# map dependencies to real packages, ignore - deps, filter out self
for $pack (@packs_to_setup) {
  #$pdeps{$pack} = [ unify(grep {$_ ne $pack} map {$subpack2pack{$_} || ()} grep {!/^-/} @{$deps{$pack} || []}) ];
  my @dl;
  for my $dep (@{$deps{$pack}}) {
    next if substr($dep,0,1) eq '-';
    if (!exists $subpack2pack{$dep}) {
      # could be versioned dep. throw away the version
      $dep =~ s/ .*//;
      if (!exists $subpack2pack{$dep}) {
	print STDERR "$pack: broken dep $dep\n";
	next;
      }
    }
    $dep = $subpack2pack{$dep};
    if ($pack eq $dep) {
      print "$pack: self req\n" if $verbose;
      next;
    }
    push @dl, $dep;
  }
  $pdeps{$pack} = [ unify @dl ];
}
taskdone;

@todo = @packs_to_setup;

if ($debug) {
  open(FOO, '>', "$ddir/dep1");
  print FOO Data::Dumper->Dump(
    [\%pdeps],
    [qw/*pdeps/]);
  close FOO;

  open(FOO, '>', "$ddir/dep2");
  print FOO Data::Dumper->Dump(
    [\%deps],
    [qw/*deps/]);
  close FOO;

  open(FOO, '>', "$ddir/dep3");
  print FOO Data::Dumper->Dump(
    [\%subpack2pack],
    [qw/*subpack2pack/]);
  close FOO;
}

my $numpacks = @todo;

taskstart "computing dependency graph";

use Dfs;
my $dfs = new Dfs(\%pdeps);
$dfs->startrdfs(@todo);

taskdone;

### cycle elimination
#
taskstart "finding cycles";
my %cycles = $dfs->findcycles();
# put all packages involved in a cycle in the hash,
# calculate cycle build time
for my $c (keys %cycles) {
  my $cn = join(',', sort(@{$cycles{$c}}));
#  $cycles{$cn} = $cycles{$c};
  my $eti = 0;
  for my $p (@{$cycles{$c}}) {
    $cycles{$p} = $cn;
    # find longest time
    # FIXME: add all times
    $eti = $buildtime{$p} if $eti < $buildtime{$p};
  }
  # twice the time of the longest package
  $eti *= 2;
  $buildtime{$cn} = $eti;
}

my %cycledeps; # collects deps of the packages of a cycle 
for my $p (keys %pdeps) {
  # replace dep to packages involved in a cycle to cycle dep
  my %h = map {
    # preserve deps of own cycle
    if (!exists $cycles{$_}
    || (exists $cycles{$p} && $cycles{$_} eq $cycles{$p})) {
      $_ => 1;
    } else {
      $cycles{$_} => 1;
    }
  } @{$pdeps{$p}};

  if (exists $cycles{$p}) {
    push @{$cycledeps{$cycles{$p}}}, keys %h;
  } else {
    @{$pdeps{$p}} = keys %h;
  }
}
# inject the cycles as package
for my $p (keys %cycledeps) {
  @{$pdeps{$p}} = grep {!exists $cycles{$_}} unify(@{$cycledeps{$p}});
}

taskdone;

if ($debug) {
  open(FOO, '>', "$ddir/dep4");
  print FOO Data::Dumper->Dump(
    [\%pdeps],
    [qw/*pdeps/]);
  close FOO;
}

my $firstcycle;
if (exists $cycles{'autoconf'}) {
  $firstcycle = $cycles{'autoconf'};
  if ($verbose) {
    print "Basepacks timings:\n";
    for $pack (split(',', $cycles{'autoconf'})) {
      print "$pack: $buildtime{$pack}\n";
    }
    print "Total: ", hhmm($buildtime{$cycles{'autoconf'}}),"\n";
    print "first cycle: $firstcycle\n";
  }
}

# remove packages involved in cycle from @todo, add cycle instead
{
  my %cycledone;
  @todo = grep {
    if (exists $cycles{$_}) {
      if (exists $cycledone{$cycles{$_}}) {
	0;
      } else {
	$cycledone{$cycles{$_}} = 1;
	$_ = $cycles{$_};
      }
    } else {
      1;
    }
  } @todo;
}

# walk the now cycle free graph again
$dfs = new Dfs(\%pdeps);
$dfs->startrdfs(@todo);
#print Dumper(\@todo);
#print Dumper($dfs->{'reversedgraph'});
#print Dumper($dfs->{'reverseorder'});

my $ti = 0;
my $nbuild = 0;

open(FOO, '>', "$ddir/deps");
print FOO "f $firstcycle\n";
while (my ($p, $d) = each %pdeps) {
  print FOO "b $p ", $buildtime{$p}, ' ', join(' ', @$d), "\n";
}
close FOO;

#%deppath = ();

my %nbuild = ();
my %nwait = ();

my $cnt = 0;

my $nwait = @todo;
for my $p (splice @todo) {
    if($dfs->{'reverseorder'}->{$p}==0) {
	push @todo, $p;
    }
}

taskstart "Starting simulation with $nwait packages";

my %building;
my %finished;
while ($nwait || $nbuild)
{
  ++$cnt;
  last if $maxiter && $cnt > $maxiter;
  my $numstarted = 0;

  if ($ti) {
    die "BUG: nothing finishes at $ti!\n" unless exists $building{$ti};
    my $nfinish = @{$building{$ti}};
    $nbuild -= $nfinish;
    for my $p (@{$building{$ti}}) {
      print "$ti: finished $p\n" if $verbose;
      push @done, $p;
      $finished{$p} = $ti;
      for my $dep (@{$dfs->{'reversedgraph'}->{$p}}) {
	$dfs->{'reverseorder'}->{$dep}--;
	push @todo, $dep if $dfs->{'reverseorder'}->{$dep} == 0;
      }
      delete $dfs->{'reverseorder'}->{$p};
    }
    delete $building{$ti};
  }

  $nbuild += @todo;
  $numstarted += @todo;
  $nwait -= @todo;
  die "nwait < 0\n" if $nwait < 0;
  my $i = 0;
  for my $p (splice @todo) {
    my $eti = 0;
    $eti = $buildtime{$p};
    $eti += $ti;
    print "$ti: starting $p, will finish at $eti\n" if $verbose;
    $building{$eti} = [] unless exists $building{$eti};
    push @{$building{$eti}}, $p;
  }

  $nbuild{$ti} = $nbuild;
  $nwait{$ti}  = $nwait;
  print "$ti: build $nbuild wait $nwait started $numstarted\n" if $verbose;

  if ($nbuild == 0 && $nwait > 0) {
    die "deadlocked\n";
  }

  my $nextti = 0;
  for my $t (keys %building) {
    if (!$nextti) {
      $nextti = $t;
      next;
    }
    $nextti = $t if $t < $nextti;
  }
  last unless $nextti;
  $ti = $nextti;
}
$nbuild{$ti} = 0;
$nwait{$ti}  = 0;
$maxtime = $ti;

taskdone;

open(OUT, '>', "$ddir/simul");
print OUT "n $numpacks\n";
while (my ($ti, $nb) = each %nbuild) {
  printf OUT "t %d %d %d\n", $ti, $nb, $nwait{$ti};
}
while (my ($p, $ti) = each %finished) {
  printf OUT "f %s %d\n", $p, $ti;
}
close OUT;

drawgraph:
if ($opt_justgraph) {
  taskstart "reading deps";
  open(IN, '<', "$ddir/deps") || die "$!";
  while (<IN>) {
    chomp;
    my @a = split(/ /);
    if ($a[0] eq 'f') {
      $firstcycle = $a[1];
    } elsif ($a[0] eq 'b') {
      $buildtime{$a[1]} = $a[2];
      $pdeps{$a[1]} = [@a[3 .. $#a]];
      push @packs_to_setup, $a[1] unless $a[1] =~ /,/;
    }
  }
  close IN;
  open(IN, '<', "$ddir/simul") || die "$!";
  while (<IN>) {
    chomp;
    my @a = split(/ /);
    if ($a[0] eq 'n') {
      $numpacks = $a[1];
    } elsif ($a[0] eq 't') {
      $nbuild{$a[1]} = $a[2];
      $nwait{$a[1]} = $a[3];
    } elsif ($a[0] eq 'f') {
      $finished{$a[1]} = $a[2];
    }
  }
  @done = sort {$finished{$a} <=> $finished{$b}} keys %finished;
  close IN;
  for (keys %nbuild) {
    $maxtime = $_ if ($maxtime < $_);
  }
  taskdone;
}

my $packalias = {};
$packalias->{$firstcycle} = 'basepacks' if $firstcycle;
for my $p (@done) {
  next unless $p =~ /^OpenOffice_org/;
  my $q = $p;
  $q =~ s/OpenOffice_org/OOo/;
  $packalias->{$p} = $q;
}

my $last;

if ($opt_interesting) {
  $last = [$opt_interesting];
} else {
  $last = \@done;
}

my @longest;
my %longest;
my $i = 0;
my $lastfincols = 0;
for my $p (reverse @$last) {
  next if exists $longest{$p};
  my $path = [];
  while(1) {
    push @$path, $p;
    $longest{$p} = 1;
    last unless @{$pdeps{$p}};
    my $l;
    for my $dep (@{$pdeps{$p}}) {
      if (!$l) {
	$l = $dep;
	next;
      }
      $l = $dep if $finished{$l} < $finished{$dep};
    }
    $p = $l;
  }
  push @longest, $path;
  $lastfincols = @$path if $lastfincols < @$path;
  ++$i;
  last unless $opt_interesting || $i < $numlongest;
}

# interesting points in time
my %inttimes = ();

{
  my %needed = map {$_ => 0} @done;
  for my $p (@done) {
    for (@{$pdeps{$p}}) {
      $needed{$_}++;
    }
  }

  for my $p (@{$longest[0]}) {
    # skip package with short build time that doesn't trigger many
    # other packages
    next if !$opt_allinteresting && $buildtime{$p} < 900 && $needed{$p} < 20;
    $inttimes{$finished{$p}} = (exists $packalias->{$p})?$packalias->{$p}:$p;
  }
  if ($verbose) {
    print "Interesting:\n";
    for my $t (sort {$a <=> $b} keys %inttimes) {
      print "$t: $inttimes{$t}\n";
    }
  }
}

taskstart "creating output";

require RebuildGraph;
open(IMG, ">$ddir/rebuild.png") || die("$ddir/rebuild.png: $!\n");
print IMG RebuildGraph::render(
  dist => $dist,
  width => $width,
  height => $height,
  nbuild => \%nbuild,
  nwait => \%nwait,
  inttimes => \%inttimes
);
close IMG;

no strict;

open(IN, "<$templdir/disttemplate.html") || die("$templdir/disttemplate.html: $!\n");
my $in = '';
while (sysread(IN, $in, 4096, length($in)) > 0) {}
close IN;

$in =~ s/\<DIST\>/$dist/sg;
$h=hhmm($maxtime);
$in =~ s/\<REBUILDTIME\>/$h/sg;
$in =~ s/\<NUMPACKS\>/$numpacks/sg;

$colspan = $lastfincols * 3 + 1;
$ltab = "<table cellpadding=0 cellspacing=0 border=0>\n<tr>\n<td colspan=$colspan width=1 bgcolor=\"#336699\"><img src=void.gif width=1 height=1 border=0></td>\n</tr>\n";
for $lf (@longest) {
  $ltab .= "<tr>\n";
  unshift @$lf, '' while @$lf < $lastfincols;
  for $q (@$lf) {
    $ltab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=18 border=0></td>\n";
    if ($q ne '') {
      $qn = (exists $packalias->{$q})?$packalias->{$q}:$q;
      $ltab .= "<td>&nbsp;$qn:</td>\n";
      $h=hhmm($buildtime{$q});
      $hf=hhmm($finished{$q});
      $ltab .= "<td align=right>&nbsp;$h&nbsp;<br>&nbsp;$hf&nbsp;</td>\n";
    } else {
      $ltab .= "<td>&nbsp;</td><td>&nbsp;</td>\n";
    }
  }
  $ltab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=1 border=0></td>\n";
  $ltab .= "</tr>\n";
}
$ltab .= "<tr>\n<td colspan=$colspan width=1 bgcolor=\"#336699\"><img src=void.gif width=1 height=1 border=0></td>\n</tr>\n</table>\n";
$in =~ s/\<TABLE_LONGEST\>/$ltab/s;

my @buildtime = sort {$buildtime{$b} <=> $buildtime{$a}} @packs_to_setup;
$rtab = "<table cellpadding=0 cellspacing=0 border=0>\n<tr>\n<td colspan=7 width=1 bgcolor=\"#336699\"><img src=void.gif width=1 height=1 border=0></td>\n</tr>\n";
$rtab .= "<tr>\n";
$rtab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=18 border=0></td>\n";
$rtab .= "<td align=center bgcolor=\"#336699\">&nbsp;&nbsp;&nbsp;<font color=\"#ffffff\"><i>Package</i></font>&nbsp;&nbsp;&nbsp;</td>\n";
$rtab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=1 border=0></td>\n";
$rtab .= "<td align=center
bgcolor=\"#336699\">&nbsp;&nbsp;&nbsp;<font color=\"#ffffff\"><i>build time</i></font>&nbsp;&nbsp;&nbsp;</td>\n";
$rtab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=1 border=0></td>\n";
$rtab .= "</tr>\n";
$rtab .= "<tr>\n<td colspan=7 width=1 bgcolor=\"#336699\"><img src=void.gif width=1 height=1 border=0></td>\n</tr>\n";
for $pack (splice(@buildtime, 0, 50)) {
  $rtab .= "<tr>\n";
  $rtab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=18 border=0></td>\n";
  $rtab .= "<td bgcolor=\"#eeeeee\">&nbsp;$pack&nbsp;</td>\n";
  $rtab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=1 border=0></td>\n";
  $h = hhmm($buildtime{$pack});
  $rtab .= "<td align=right>&nbsp;&nbsp;&nbsp;$h&nbsp;&nbsp;&nbsp;</td>\n";
  $rtab .= "<td width=1 bgcolor=\"#336699\"><img src=\"void.gif\" width=1 height=1 border=0></td>\n";
  $rtab .= "</tr>\n";
}
$rtab .= "<tr>\n<td colspan=7 width=1 bgcolor=\"#336699\"><img src=void.gif width=1 height=1 border=0></td>\n</tr>\n</table>\n";
$in =~ s/\<TABLE_LONGPACKS\>/$rtab/s;

open(IN, ">$ddir/index.html") || die("$ddir/index.html: $!\n");
print IN $in;
close IN;

taskdone;
